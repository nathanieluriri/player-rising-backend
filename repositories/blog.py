# ============================================================================
# BLOG REPOSITORY
# ============================================================================
# This file was auto-generated on: 2025-11-14 11:54:23 WAT
# It contains asynchronous functions for managing access to the database
# in a MongoDB database using FastAPI.
#
# DO NOT EDIT THIS FILE MANUALLY - RE-RUN THE GENERATOR INSTEAD. OR IF YOU WANT TO EDIT JUST ADD LEAVE OTHER FUNCTIONS THE WAY YOU MET THEM
# ============================================================================

from pymongo import ReturnDocument
from core.database import db
from fastapi import HTTPException,status
from typing import List,Optional
from schemas.blog import BlogUpdate, BlogCreate, BlogOut

async def create_blog(blog_data: BlogCreate) -> BlogOut:
    blog_dict = blog_data.model_dump()
    result =await db.blogs.insert_one(blog_dict)
    result = await db.blogs.find_one(filter={"_id":result.inserted_id})
    returnable_result = BlogOut(**result)
    return returnable_result

async def get_blog(filter_dict: dict) -> Optional[BlogOut]:
    try:
        result = await db.blogs.find_one(filter_dict)

        if result is None:
            return None

        return BlogOut(**result)

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching blog: {str(e)}"
        )
    
async def get_blogs(
    filter_dict: Optional[dict] = None,
    start: int = 0,
    stop: int = 100,
    sort_field: Optional[str] = None,
    sort_order: Optional[int] = None  # 1 for ascending, -1 for descending
) -> List[BlogOut]:
    """
    Retrieves blogs from the MongoDB collection with optional filtering,
    pagination, and sorting.

    Args:
        filter_dict (dict, optional): MongoDB filter criteria.
        start (int): Start index for pagination.
        stop (int): Stop index for pagination.
        sort_field (str, optional): Field to sort by.
        sort_order (int, optional): 1 for ascending, -1 for descending.

    Returns:
        List[BlogOut]: List of blog objects sorted by the given field.
                       If no sort_field or sort_order is provided,
                       results are sorted by `datecreated` descending
                       (newest first).
    """
    try:
        if filter_dict is None:
            filter_dict = {}

        # Base query
        cursor = db.blogs.find(filter_dict)

        # Apply sorting
        if sort_field and sort_order:
            cursor = cursor.sort(sort_field, sort_order)
        else:
            # Default sorting: newest first
            cursor = cursor.sort("date_created", -1)

        # Apply pagination AFTER sorting
        cursor = cursor.skip(start).limit(stop - start)

        blog_list = []
        async for doc in cursor:
            blog_list.append(BlogOut(**doc))

        return blog_list

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching blogs: {str(e)}"
        )

async def update_blog(filter_dict: dict, blog_data: BlogUpdate) -> BlogOut:
    result = await db.blogs.find_one_and_update(
        filter_dict,
        {"$set": blog_data.model_dump(exclude_none=True)},
        return_document=ReturnDocument.AFTER
    )
    returnable_result = BlogOut(**result)
    return returnable_result

async def delete_blog(filter_dict: dict):
    return await db.blogs.delete_one(filter_dict)